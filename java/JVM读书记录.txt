1. JVM可能使用TLAB来保证多线程下新对象内存分配的正确性，及每个线程在堆上有属于自己的一块TLAB（本地线

程分配缓冲），每个线程进行对象创建时，都会先在TLAB上进行分配，只有TLAB不足时，才会进行TLAB的扩充，一

定程度上避免了高并发下多线程对象分配内存的冲突的存在，可以使用 -XX:+/-UserTLAB参数来设定TLAB的开启。

2. 对象在堆中包含三部分，对象头，实例数据以及对齐填充，其中对象头（大小为8字节的倍数，一般为一倍或者

两倍）又分为用于存储自身运行时数据（如哈希吗、GC分代年龄、锁状态标志等）和用于指向自身类元数据的类型

指针，实例数据存储程序中定义的各种类型的字段内容，是真正存储的有效信息，而对齐填充就是占位符，不一定

存在，HotSpot VM要求对象起始地址必须是8字节的倍数，因此需要对齐填充来占位达到8字节的倍数。

3. 内存泄露指无用对象无法释放导致的内存不足，内存溢出指申请的内存大于剩余内存导致的OOM

4. 任何一个对象的finalize()方法都只能执行一次

5. 准确式GC指的是JVM知道内存中某个位置上的数据是什么类型，从而快速判断所有引用类型的位置

6. CMS是并发收集器，包括初始标记、并发标记、重新标记以及并发清除四个过程，默认启动（cpu数+ 3）/ 4个垃

圾回收线程，因此在cpu数量少的时候，程序运行效率会下降的很明显。

7. 虚拟机给每个对象定义了一个年龄计数器，在年轻代中的对象每经过一次Minor GC后，该对象的年龄加一，到达

设置的最大年龄后（-XX:MaxTenuring Threshold参数 默认为15），会被移交到老年代，另外如果同年龄的对象大

小之和大于Survivor的一半的话，年龄大于等于该年龄的对象都会移交到老年代中，不用等到年龄达到设置的最大

值再移交。

8. 如果老年代最大连续空间大于年轻代对象总大小或者大于历次晋升的平均大小，就会采取Minor GC，否则采取

Full GC

9. OOM可能发生在栈、堆、方法区以及直接内存中，直接内存不算在堆内存中，是NIO使用NATIVE本地函数库在堆外

分配的一块本地内存，在堆内使用DirectByteBuffer对象保持对直接内存的引用，防止数据频繁在本地内存与虚拟

机之间进行复制，提高了效率，Xmx设置的最大堆内存不包括直接内存，在我们的设备内存一定的情况下，堆内存越

大，显然可分配的本地内存就会越小，并且直接内存只有在Full GC的时候才能被“顺便”回收，不能像新生代老年

代那样，内存不足了就通知收集器进行回收，当其空间不足的时候，如果没有Full GC，那么就会出现OOM，因此当

发生OOM的时候，不要盲目的调大Xmx，因为可能OOM是发生在直接内存中的（注意报错中是否有directByteBuffer字

样），这时候你调大Xmx，可分配的直接内存就会更小，OOM就会更加频繁。

10. 理论上来讲，由于JIT编译器的存在，eclipse开的时间越长，运行速度越快。
