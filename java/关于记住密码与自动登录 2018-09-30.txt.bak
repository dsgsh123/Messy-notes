最近在实现rememberMe的功能（不使用框架）时，发现现今已经摒弃了那种勾选了记住密码后，通过cookie存储用户名和密码，然后再在网页上自动填写，之后还要手动点击登录的方式（即记住密码单没有自动登录），原因在于这种方式一定需要通过js将cookie取出然后再赋值到input标签中，这样做存在极大的安全隐患，因为此时input中填写的密码必须要是明文的，此时一旦电脑被别人获取，很容易就可以通过修改input的类型得到明文密码，同时还会存在XSS攻击，但目前来讲，这种实现需求是无法解决这种安全问题的，因为这种自动填写-手动再点击登录的rememberMe方式必须要通过这种方式来实现，无法避免给input设置值，所以，现如今的解决方式是rememberMe摒弃这种方式，转而变为记住密码-自动登录，这种方式当选择了rememberMe后，不会再进入登录页面，而是直接通过后台进行cookie获取和身份验证，通过后直接跳转到如index页面，这样以来，不存在登录页面（哪怕输入登录的url也不会进入登录页面，只能通过注销时删除相应的cookie后或者cookie过期，才能再次进入登录页面），自然也就避免了上述的通过修改html来获取密码的隐患。

实现自动登录功能时，尽量要保证：

1.对密码进行限制，不能过于简单
2.永远不能使用明文传输密码。密码加密可以使用多次加密、加盐等，因为现如今某些加密算法如md5已经可以被破解
3.尽量使用https的方式进行网路传输
4.千万不要在cookie中保存密码，自动登录的身份验证可以使用其他方式来实现



关于实现：
目前常用做法是，cookie中保存用户名、token以及登录序列series（token和series都会保存在数据库中），自动登录时会验证这三点
其中 
1.无论是口令登录还是自动登录，每次登录都会重新生成token（不重复的散列）
2.每次通过口令登录的时候，都会重新生成series，自动登录时则保持不变

这样，在浏览器A首次登录时，会生成seriesA和tokenA，此时如果通过自动登录再次登录，seriesA不变，tokenA重新更新为tokenA1，之后如果浏览器B通过口令登录，会生成seriresB和tokenB，之后浏览器A再自动登录时，会发现seires与数据库中不再匹配，从而跳转到口令登录页面；
如果发生了cookie盗取，某浏览器C盗取了A的cookie后，通过cookie进行自动登录，此时会生成tokenC，之后浏览器A再次登录时，会发现series匹配但是token不匹配，出现这种情况则代表cookie被盗，从而提示用户被盗。

此外还可以考虑ip的问题，比如我们假定同ip的情况下是安全的（在某些公共场所尽量不要使用），即同ip的口令登录不会更新series（即口令登录先判断是否同ip，若同ip，则直接从数据库中获取seires，若为空则生成seires并保存）